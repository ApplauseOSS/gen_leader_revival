diff --git a/src/elibs/gen_leader.erl b/src/elibs/gen_leader.erl
index fccc516..d471b59 100644
--- a/src/elibs/gen_leader.erl
+++ b/src/elibs/gen_leader.erl
@@ -61,7 +61,7 @@
 
 -export([start/6,
 	 start_link/6,
-	 leader_call/2, leader_call/3, leader_cast/2,
+	 leader_call/2, leader_call/3, leader_cast/2, worker_announce/2,
 	 call/2, call/3, cast/2,
 	 reply/2]).
 
@@ -200,6 +200,11 @@ candidates(#election{candidate_nodes = Cands}) ->
 workers(#election{worker_nodes = Workers}) ->
     Workers.
 
+%% Used by dynamically added workers.
+%% @hidden
+worker_announce(Name, Pid) ->
+  Name ! {add_worker, Pid}.
+
 %
 % Make a call to a generic server.
 % If the server is located at another node, that node will
@@ -320,10 +325,9 @@ init_it(Starter, self, Name, Mod, {CandidateNodes, Workers, Arg}, Options) ->
     init_it(Starter, self(), Name, Mod, 
 	    {CandidateNodes, Workers, Arg}, Options);
 init_it(Starter,Parent,Name,Mod,{CandidateNodes,Workers,Arg},Options) ->
-    
     %% The following row is needed in case of trace analysis,
     %% starting tracing is too slow otherwise!
-    %receive after 100 -> ok end,
+    receive after 100 -> ok end,
     
     Debug = debug_options(Name, Options),
 
@@ -335,29 +339,34 @@ init_it(Starter,Parent,Name,Mod,{CandidateNodes,Workers,Arg},Options) ->
 			  nextel = 0},
 
     case {catch Mod:init(Arg), AmCandidate} of
-	{{stop, Reason},_} ->
-	    proc_lib:init_ack(Starter, {error, Reason}),
-	    exit(Reason);
-	{ignore,_} ->
-	    proc_lib:init_ack(Starter, ignore),
-	    exit(normal);
-	{{'EXIT', Reason},_} ->
-	    proc_lib:init_ack(Starter, {error, Reason}),
-	    exit(Reason);
-	{{ok, State}, true} ->
-	    NewE = startStage1(Election#election{incarn = incarnation(node())}),
-
-	    proc_lib:init_ack(Starter, {ok, self()}),
-	    safe_loop(#server{parent = Parent,mod = Mod,state = State,debug = Debug}, 
-		      candidate, NewE,{init});
-	{{ok, State}, false} ->
-	    proc_lib:init_ack(Starter, {ok, self()}), 	  
-	    safe_loop(#server{parent = Parent,mod = Mod,state = State,debug = Debug}, 
-		      waiting_worker, Election,{init});
-	Else ->
-	    Error = {bad_return_value, Else},
-	    proc_lib:init_ack(Starter, {error, Error}),
-	    exit(Error)
+      {{stop, Reason},_} ->
+        proc_lib:init_ack(Starter, {error, Reason}),
+        exit(Reason);
+      {ignore,_} ->
+        proc_lib:init_ack(Starter, ignore),
+        exit(normal);
+      {{'EXIT', Reason},_} ->
+        proc_lib:init_ack(Starter, {error, Reason}),
+        exit(Reason);
+      {{ok, State}, true} ->
+        NewE = startStage1(Election#election{incarn = incarnation(node())}),
+        
+        proc_lib:init_ack(Starter, {ok, self()}),
+        safe_loop(#server{parent = Parent,mod = Mod,state = State,debug = Debug}, 
+                  candidate, NewE,{init});
+      {{ok, State}, false} ->
+        proc_lib:init_ack(Starter, {ok, self()}),
+        case lists:member(self(), Workers) of 
+          false ->
+            rpc:multicall(CandidateNodes, gen_leader, worker_announce, [Name, node(self())]);
+          _ -> nop
+        end,
+        safe_loop(#server{parent = Parent,mod = Mod,state = State,debug = Debug}, 
+                  waiting_worker, Election,{init});
+      Else ->
+        Error = {bad_return_value, Else},
+        proc_lib:init_ack(Starter, {error, Error}),
+        exit(Error)
     end.
 
 
@@ -369,7 +378,7 @@ init_it(Starter,Parent,Name,Mod,{CandidateNodes,Workers,Arg},Options) ->
 
 
 safe_loop(#server{mod = Mod, state = State} = Server, Role,
-	  #election{name = Name} = E, PrevMsg) ->
+	  #election{name = Name} = E, _PrevMsg) ->
     % Event for QuickCheck
     % ?EVENT({Role,E}),
     receive
@@ -379,6 +388,9 @@ safe_loop(#server{mod = Mod, state = State} = Server, Role,
 				  [safe, Server, Role, E]);
 	{'EXIT', _, Reason} = Msg ->
 	    terminate(Reason, Msg, Server, Role, E);
+  {report_leader, From} = Msg ->
+        From ! {election_leader, self(), E#election.leader},
+        safe_loop(Server, Role, E, Msg);
 	{halt,T,From} = Msg ->
 	    NewE = halting(E,T,From),
 	    From ! {ackLeader,T,self()},
@@ -421,13 +433,14 @@ safe_loop(#server{mod = Mod, state = State} = Server, Role,
 		    NewE = E
 	    end,
 	    hasBecomeLeader(NewE,Server,Msg);
-	{ldr,Synch,T,From} = Msg ->
+	{ldr,Synch,T,From, LeaderE} = Msg ->
 	    case ( (E#election.status == wait) and (E#election.elid == T) ) of
 		true ->
 		    NewE1 = mon_node(E,From),
 		    NewE = NewE1#election{leader = From,
 					  leadernode = node(From),
-					  status = norm},
+					  status = norm,
+            worker_nodes = LeaderE#election.worker_nodes},
 		    {ok,NewState} = Mod:surrendered(State,Synch,NewE),
 		    loop(Server#server{state = NewState},surrendered,NewE,Msg);
 		false ->
@@ -464,11 +477,11 @@ safe_loop(#server{mod = Mod, state = State} = Server, Role,
 	    % This process is no longer the leader!
 	    % The sender will notice this via a DOWN message
 	    safe_loop(Server,Role,E,Msg);
-	{activateWorker,T,Synch,From} = Msg ->
+	{activateWorker,T,Synch,From,OldE} = Msg ->
 	    case ( (T == E#election.elid) and (node(From) == E#election.leadernode)) of
 		true ->
 		    NewE = E#election{ leader = From,
-				       status = worker },
+				       status = worker, worker_nodes = OldE#election.worker_nodes },
 		    {ok,NewState} = Mod:surrendered(State,Synch,NewE),
 		    loop(Server#server{state = NewState},worker,NewE,Msg);
 		false ->
@@ -480,7 +493,7 @@ safe_loop(#server{mod = Mod, state = State} = Server, Role,
 	
 	{tau_timeout} = Msg ->
 	    safe_loop(Server,Role,E,Msg);
-	{'DOWN',Ref,process,From,Reason} = Msg when Role == waiting_worker ->
+	{'DOWN',_Ref,process,From,_Reason} = Msg when Role == waiting_worker ->
 	    % We are only monitoring one proc, the leader!
 	    Node = case From of
 		       {Name,_Node} -> _Node;
@@ -495,7 +508,7 @@ safe_loop(#server{mod = Mod, state = State} = Server, Role,
 		    NewE = E
 	    end,  
 	    safe_loop(Server, Role, NewE,Msg);
-	{'DOWN',Ref,process,From,Reason} = Msg ->
+	{'DOWN',Ref,process,From,_Reason} = Msg ->
 	    Node = case From of
 		       {Name,_Node} -> _Node;
 		       _ when pid(From) -> node(From)
@@ -536,166 +549,179 @@ safe_loop(#server{mod = Mod, state = State} = Server, Role,
 			    end
 		    end 
 	    end,
-	    hasBecomeLeader(NewE,Server,Msg)
+      hasBecomeLeader(NewE,Server,Msg)
     end.
 
 
 loop(#server{parent = Parent,
-	     mod = Mod,
-	     state = State,
-	     debug = Debug} = Server, Role, #election{name = Name} = E, PrevMsg) ->
-    % Event for QuickCheck
-    % ?EVENT({Role,E}),
-    receive
-	Msg ->
-	    
+             mod = Mod,
+             state = State,
+             debug = Debug} = Server, Role, #election{name = Name} = E, _PrevMsg) ->
+                                                % Event for QuickCheck
+                                                % ?EVENT({Role,E}),
+  receive
+    Msg ->
+
 	    case Msg of
-		{system, From, Req} ->
-		    sys:handle_system_msg(Req, From, Parent, ?MODULE, Debug,
-					  [normal, Server, Role, E]);
-		{'EXIT', Parent, Reason} ->
-		    terminate(Reason, Msg, Server, Role, E);
-
-		{halt,_,From} ->
-		    From ! {hasLeader,E#election.leader,E#election.elid,self()},
-		    loop(Server,Role,E,Msg);
-		{hasLeader,_,_,_} ->
-		    loop(Server,Role,E,Msg);
-		{isLeader,T,From} ->
-		    case (self() == E#election.leader) of
-			true -> 
-			    NewE = mon_node(E#election{down = E#election.down -- [node(From)]},
-						 From),
-			    {ok,Synch,NewState} = Mod:elected(State,NewE),
-			    From ! {ldr,Synch,E#election.elid,self()}, 
-			    loop(Server#server{state = NewState},Role,NewE,Msg);	
-			false ->
-			    From ! {notLeader,T,self()},
-			    loop(Server,Role,E,Msg)
-		    end;
-		{ackLeader,_,_} -> 
-		    loop(Server,Role,E,Msg);
-		{notLeader,_,_} ->
-		    loop(Server,Role,E,Msg);
-		{ack,_,_} ->
-		    loop(Server,Role,E,Msg);
-		{ldr,_,_,_} ->
-		    loop(Server,Role,E,Msg);
-		{normQ,_,_} ->
-		    loop(Server,Role,E,Msg);
-		{notNorm,T,From} ->
-		    case ( (E#election.leader == self()) and (E#election.elid == T) ) of 
-			true ->
-			    NewE = mon_node(E#election{down = E#election.down -- [node(From)]},
-						 From),
-			    {ok,Synch,NewState} = Mod:elected(State,NewE),
-			    From ! {ldr,Synch,E#election.elid,self()},
-			    loop(Server#server{state = NewState},Role,NewE,Msg);	
-			false ->
-			    loop(Server,Role,E,Msg)
-		    end;
-		{workerAlive,_,_} ->
-		    % Do nothing if we get this from a new leader
-		    % We will soon notice that the prev leader has died, and
-		    % get the same message again when we are back in safe_loop!
-		    loop(Server,Role,E,Msg);
-		{activateWorker,_,_,_} ->
-		    % We ignore this, we are already active... 
-		    % It must be an old message!
-		    loop(Server,Role,E,Msg);
-		{workerIsAlive,T,From} ->
-		    case ((T == E#election.elid) and (self() == E#election.leader) 
-			        %            and iselem(node(From),E#election.monitored)
-                                ) of
-			true ->
- 			    NewE = mon_node(
- 				     E#election{work_down = E#election.work_down -- [node(From)]},
- 				     From),
-%			    NewE = E#election{work_down = E#election.work_down -- [node(From)]},
-			    {ok,Synch,NewState} = Mod:elected(State,NewE),
-			    From ! {activateWorker,T,Synch,self()},
-			    loop(Server#server{state = NewState},Role,NewE,Msg);		
-			false ->
-		            loop(Server,Role,E,Msg)
-		    end;
-		{tau_timeout} ->
-		    case (E#election.leader == self()) of
-			true ->
-			    lists:foreach(
-			      fun(Node) ->
-				      {Name,Node} ! {normQ,E#election.elid,self()}
-			      end,E#election.down -- [lists:nth(1,E#election.candidate_nodes)]),
-			    
-			    lists:foreach(
-			      fun(Node) ->
-				      {Name,Node} ! {workerAlive,E#election.elid,self()}
-			      end,E#election.work_down),
-
-			    timer:send_after(?TAU,{tau_timeout});
-			false ->
-			    ok
-		    end,
-		    loop(Server,Role,E,Msg);
-		{'DOWN',Ref,process,From,Reason} when Role == worker ->
-		    % We are only monitoring one proc, the leader!
-		    Node = case From of
-			       {Name,_Node} -> _Node;
-			       _ when pid(From) -> node(From)
-			   end,
-		    case Node == E#election.leadernode of
-			true ->
-			    NewE = E#election{ leader = none, leadernode = none,
-					       status = waiting_worker,
-					       monitored = []},
-			    safe_loop(Server, waiting_worker, NewE,Msg);
-			false ->
-			    loop(Server, Role, E,Msg)
-		    end;		    
-		{'DOWN',Ref,process,From,Reason} ->
-		    Node = case From of
-			       {Name,_Node} -> _Node;
-			       _ when pid(From) -> node(From)
-			   end,
-		    NewMon = E#election.monitored -- [{Ref,Node}],
-		    case lists:member(Node,E#election.candidate_nodes) of
-			true ->
-			    NewDown = [Node | E#election.down],
-			    E1 = E#election{down = NewDown, monitored = NewMon},
-			    case (Node == E#election.leadernode) of
-				true -> 
-				    NewE = startStage1(E1),
-				    safe_loop(Server, candidate, NewE,Msg);
-				
-				false ->
-				    loop(Server, Role, E1,Msg)
-			    end;
-			false ->
-			    % I am the leader, make sure the dead worker is in work_down.
-			    E1 = E#election{monitored = NewMon,
-					    work_down = [Node | (E#election.work_down -- [Node])]
-					   },
-			    loop(Server, Role, E1,Msg)
-		    end;
-		_Msg when Debug == [] ->
-		    handle_msg(Msg, Server, Role, E);
-		_Msg ->
-		    Debug1 = sys:handle_debug(Debug, {?MODULE, print_event}, 
-					      E#election.name, {in, Msg}),
-		    handle_msg(Msg, Server#server{debug = Debug1}, Role, E)
+        {system, From, Req} ->
+          sys:handle_system_msg(Req, From, Parent, ?MODULE, Debug,
+                                [normal, Server, Role, E]);
+        {'EXIT', Parent, Reason} ->
+          terminate(Reason, Msg, Server, Role, E);
+
+        {halt,_,From} ->
+          From ! {hasLeader,E#election.leader,E#election.elid,self()},
+          loop(Server,Role,E,Msg);
+        {hasLeader,_,_,_} ->
+          loop(Server,Role,E,Msg);
+        {isLeader,T,From} ->
+          case (self() == E#election.leader) of
+            true -> 
+              NewE = mon_node(E#election{down = E#election.down -- [node(From)]},
+                              From),
+              {ok,Synch,NewState} = Mod:elected(State,NewE),
+              From ! {ldr,Synch,E#election.elid,self(), NewE}, 
+              loop(Server#server{state = NewState},Role,NewE,Msg);	
+            false ->
+              From ! {notLeader,T,self()},
+              loop(Server,Role,E,Msg)
+          end;
+        {ackLeader,_,_} -> 
+          loop(Server,Role,E,Msg);
+        {notLeader,_,_} ->
+          loop(Server,Role,E,Msg);
+        {ack,_,_} ->
+          loop(Server,Role,E,Msg);
+        {ldr,_,_,_,_} ->
+          loop(Server,Role,E,Msg);
+        {normQ,_,_} ->
+          loop(Server,Role,E,Msg);
+        {notNorm,T,From} ->
+          case ( (E#election.leader == self()) and (E#election.elid == T) ) of 
+            true ->
+              NewE = mon_node(E#election{down = E#election.down -- [node(From)]},
+                              From),
+              {ok,Synch,NewState} = Mod:elected(State,NewE),
+              From ! {ldr,Synch,E#election.elid,self(), NewE},
+              loop(Server#server{state = NewState},Role,NewE,Msg);	
+            false ->
+              loop(Server,Role,E,Msg)
+          end;
+        {workerAlive,_,_} ->
+                                                % Do nothing if we get this from a new leader
+                                                % We will soon notice that the prev leader has died, and
+                                                % get the same message again when we are back in safe_loop!
+          loop(Server,Role,E,Msg);
+        {activateWorker,_,_,_} ->
+                                                % We ignore this, we are already active... 
+                                                % It must be an old message!
+          loop(Server,Role,E,Msg);
+        {workerIsAlive,T,From} ->
+          case ((T == E#election.elid) and (self() == E#election.leader) 
+                                                %            and iselem(node(From),E#election.monitored)
+               ) of
+            true ->
+              NewE = mon_node(
+                       E#election{work_down = E#election.work_down -- [node(From)]},
+                       From),
+                                                %			    NewE = E#election{work_down = E#election.work_down -- [node(From)]},
+              {ok,Synch,NewState} = Mod:elected(State,NewE),
+              From ! {activateWorker,T,Synch,self(), NewE},
+              loop(Server#server{state = NewState},Role,NewE,Msg);		
+            false ->
+              loop(Server,Role,E,Msg)
+          end;
+        {tau_timeout} ->
+          case (E#election.leader == self()) of
+            true ->
+              lists:foreach(
+                fun(Node) ->
+                    {Name,Node} ! {normQ,E#election.elid,self()}
+                end,E#election.down -- [lists:nth(1,E#election.candidate_nodes)]),
+
+              lists:foreach(
+                fun(Node) ->
+                    {Name,Node} ! {workerAlive,E#election.elid,self()}
+                end,E#election.work_down),
+
+              timer:send_after(?TAU,{tau_timeout});
+            false ->
+              ok
+          end,
+          loop(Server,Role,E,Msg);
+        {'DOWN',_Ref,process,From,_Reason} when Role == worker ->
+                                                % We are only monitoring one proc, the leader!
+          Node = case From of
+                   {Name,_Node} -> _Node;
+                   _ when pid(From) -> node(From)
+                 end,
+          case Node == E#election.leadernode of
+            true ->
+              NewE = E#election{ leader = none, leadernode = none,
+                                 status = waiting_worker,
+                                 monitored = []},
+              safe_loop(Server, waiting_worker, NewE,Msg);
+            false ->
+              loop(Server, Role, E,Msg)
+          end;		    
+        {'DOWN',Ref,process,From,_Reason} ->
+          Node = case From of
+                   {Name,_Node} -> _Node;
+                   _ when pid(From) -> node(From)
+                 end,
+          NewMon = E#election.monitored -- [{Ref,Node}],
+          case lists:member(Node,E#election.candidate_nodes) of
+            true ->
+              NewDown = [Node | E#election.down],
+              E1 = E#election{down = NewDown, monitored = NewMon},
+              case (Node == E#election.leadernode) of
+                true -> 
+                  NewE = startStage1(E1),
+                  safe_loop(Server, candidate, NewE,Msg);
+
+                false ->
+                  loop(Server, Role, E1,Msg)
+              end;
+            false ->
+                                                % I am the leader, make sure the dead worker is in work_down.
+              E1 = E#election{monitored = NewMon,
+                              work_down = [Node | (E#election.work_down -- [Node])]
+                             },
+              loop(Server, Role, E1,Msg)
+          end;
+        {add_worker, WorkerNode} ->
+          case {node(self()) =:= node(self()), 
+                lists:member(WorkerNode, E#election.worker_nodes)} of
+            {false, _} ->
+              loop(Server, Role, E, Msg);
+            {true, false} ->
+              {WNodes, DNodes} = {E#election.worker_nodes, E#election.work_down},
+              loop(Server, Role, E#election{worker_nodes=[WorkerNode|WNodes],
+                                            work_down=[WorkerNode|DNodes]},
+                   Msg);
+            {true, true} -> % Redundancy, meet the mirror
+              loop(Server, Role, E, Msg)
+          end;
+        _Msg when Debug == [] ->
+          handle_msg(Msg, Server, Role, E);
+        _Msg ->
+          Debug1 = sys:handle_debug(Debug, {?MODULE, print_event}, 
+                                    E#election.name, {in, Msg}),
+          handle_msg(Msg, Server#server{debug = Debug1}, Role, E)
 	    end
-    end.
+  end.
 
 %%-----------------------------------------------------------------
 %% Callback functions for system messages handling.
 %%-----------------------------------------------------------------
 %% @hidden 
-system_continue(Parent, Debug, [safe, Server, Role, E]) ->
+system_continue(_Parent, _Debug, [safe, Server, Role, E]) ->
     safe_loop(Server, Role, E,{});
-system_continue(Parent, Debug, [normal, Server, Role, E]) ->
+system_continue(_Parent, _Debug, [normal, Server, Role, E]) ->
     loop(Server, Role, E,{}).
 
 %% @hidden 
-system_terminate(Reason, _Parent, Debug, [Mode, Server, Role, E]) ->
+system_terminate(Reason, _Parent, _Debug, [_Mode, Server, Role, E]) ->
     terminate(Reason, [], Server, Role, E).
 
 %% @hidden 
@@ -741,10 +767,9 @@ print_event(Dev, {noreply, State}, Name) ->
 print_event(Dev, Event, Name) ->
     io:format(Dev, "*DBG* ~p dbg  ~p~n", [Name, Event]).
 
-
 handle_msg({'$leader_call', From, Request} = Msg, 
 	   #server{mod = Mod, state = State} = Server, elected = Role, E) ->
-    case catch Mod:handle_leader_call(Request, From, State, E) of
+  case catch Mod:handle_leader_call(Request, From, State, E) of
 	{reply, Reply, NState} ->
 	    NewServer = reply(From, {leader,reply,Reply},
 			      Server#server{state = NState}, Role, E),
@@ -769,16 +794,40 @@ handle_msg({'$leader_call', From, Request} = Msg,
 	Other ->
 	    handle_common_reply(Other, Msg, Server, Role, E)
     end;
-handle_msg({from_leader, Cmd} = Msg, 
-	   #server{mod = Mod, state = State} = Server, Role, E) ->
-    handle_common_reply(catch Mod:from_leader(Cmd, State, E), 
-			Msg, Server, Role, E);
-handle_msg({'$leader_call', From, Request} = Msg, Server, Role,
+handle_msg({'$leader_call', From, Request} = Msg, 
+           Server, Role,
 	   #election{buffered = Buffered, leader = Leader} = E) ->
     Ref = make_ref(),
     Leader ! {'$leader_call', {self(),Ref}, Request},
     NewBuffered = [{Ref,From}|Buffered],
     loop(Server, Role, E#election{buffered = NewBuffered},Msg);
+handle_msg({'$leader_cast', Request} = Msg, 
+           #server{mod = Mod, state = State} = Server, 
+           elected = Role, 
+           E) ->
+  case catch Mod:handle_leader_cast(Request, State, E) of
+    {noreply, NState} ->
+      loop(Server#server{state = NState}, Role, E, Msg);
+    {noreply, Broadcast, NState} ->
+      NewE = broadcast({from_leader, Broadcast}, E),
+      loop(Server#server{state = NState}, Role, NewE, Msg);
+    {stop, Reason, NState} ->
+      {'EXIT', R} = 
+        (catch terminate(Reason, Msg, Server#server{state = NState}, Role, E)),
+      exit(R);
+    Other ->
+      handle_common_reply(Other, Msg, Server, Role, E)
+  end;
+handle_msg({'$leader_cast', _} = Msg, 
+           Server, 
+           Role, 
+           #election{buffered=_Buffered, leader = Leader} = E) ->
+  Leader ! Msg,
+  loop(Server, Role, E, Msg);
+handle_msg({from_leader, Cmd} = Msg, 
+	   #server{mod = Mod, state = State} = Server, Role, E) ->
+    handle_common_reply(catch Mod:from_leader(Cmd, State, E), 
+			Msg, Server, Role, E);
 handle_msg({Ref, {leader,reply,Reply}} = Msg, Server, Role,
 	   #election{buffered = Buffered} = E) ->
     {value, {_,From}} = keysearch(Ref,1,Buffered),
@@ -816,18 +865,22 @@ handle_msg(Msg,
 
 
 handle_common_reply(Reply, Msg, Server, Role, E) ->
-    case Reply of
-	{ok, NState} ->
-	    NewServer = handle_debug(Server#server{state = NState},
-				     Role, E, Reply),
-	    loop(NewServer, Role, E, Msg);
-	{stop, Reason, NState} ->
+  case Reply of
+    {noreply, NState} ->
+      NewServer = handle_debug(Server#server{state = NState},
+                               Role, E, Reply),
+      loop(NewServer, Role, E, Msg);
+    {ok, NState} ->
+      NewServer = handle_debug(Server#server{state = NState},
+                               Role, E, Reply),
+      loop(NewServer, Role, E, Msg);
+    {stop, Reason, NState} ->
 	    terminate(Reason, Msg, Server#server{state = NState}, Role, E);
-	{'EXIT', Reason} ->
+    {'EXIT', Reason} ->
 	    terminate(Reason, Msg, Server, Role, E);
-	_ ->
+    _ ->
 	    terminate({bad2_return_value, Reply}, Msg, Server, Role, E)
-    end.
+  end.
 
 
 reply({To, Tag}, Reply, #server{state = State} = Server, Role, E) ->
@@ -835,9 +888,9 @@ reply({To, Tag}, Reply, #server{state = State} = Server, Role, E) ->
     handle_debug(Server, Role, E, {out, Reply, To, State}).
 
 
-handle_debug(#server{debug = []} = Server, _Role, _E, Event) ->
+handle_debug(#server{debug = []} = Server, _Role, _E, _Event) ->
     Server;
-handle_debug(#server{debug = Debug} = Server, Role, E, Event) ->
+handle_debug(#server{debug = Debug} = Server, _Role, E, Event) ->
     Debug1 = sys:handle_debug(Debug, {?MODULE, print_event}, 
 			      E#election.name, Event),
     Server#server{debug = Debug1}.
@@ -848,8 +901,8 @@ handle_debug(#server{debug = Debug} = Server, Role, E, Event) ->
 
 terminate(Reason, Msg, #server{mod = Mod, 
 			       state = State,
-			       debug = Debug} = Server, Role,
-	  #election{name = Name} = E) ->
+			       debug = Debug} = _Server, _Role,
+	  #election{name = Name} = _E) ->
     case catch Mod:terminate(Reason, State) of
 	{'EXIT', R} ->
 	    error_info(R, Name, Msg, State, Debug),
@@ -920,7 +973,7 @@ dbg_opts(Name, Opts) ->
 %%-----------------------------------------------------------------
 %% @hidden 
 format_status(Opt, StatusData) ->
-    [PDict, SysState, Parent, Debug, [Mode, Server, Role, E]] = StatusData,
+    [PDict, SysState, Parent, Debug, [_Mode, Server, _Role, E]] = StatusData,
     Header = lists:concat(["Status for generic server ", E#election.name]),
     Log = sys:get_debug(log, Debug, []),
     #server{mod = Mod, state = State} = Server,
@@ -1001,7 +1054,7 @@ mon_nodes(E,Nodes) ->
 %% Star monitoring one Process
 mon_node(E,Proc) ->
     Node = case Proc of
-	       {Name,Node_} -> 
+	       {_Name,Node_} -> 
 		   Node_;
 	       Pid when pid(Pid) -> 
 		   node(Pid)
@@ -1030,7 +1083,7 @@ hasBecomeLeader(E,Server,Msg) ->
 	    lists:foreach(
 	      fun(Node) ->
 		      {E#election.name,Node} ! 
-			  {ldr, Synch, E#election.elid, self()}
+			  {ldr, Synch, E#election.elid, self(), E}
 	      end,E#election.acks),
 
 	    % Make sure we will try to contact all workers!
@@ -1060,7 +1113,7 @@ hasBecomeLeader(E,Server,Msg) ->
 %
 incarnation(Node) ->
     case file:read_file_info(Node) of
-	{error,Reason} ->
+	{error,_Reason} ->
 	    ok = file:write_file(Node,term_to_binary(1)),
 	    0;
 	{ok,_} ->
